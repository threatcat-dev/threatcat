package threatdragon

import (
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"path"
	"slices"

	"github.com/google/uuid"
	"github.com/threatcat-dev/threatcat/internal/common"
)

type ThreatdragonOutput struct {
	OutputPath string
	cl         changelog
	logger     *slog.Logger
}

type changelog interface {
	AddEntry(string)
}

var ErrAssetTypeNoMapping = errors.New("the used AssetType has no mapping to threatdragonAssetInfo")

func NewThreatdragonOutput(outputPath string, cl changelog, logger *slog.Logger) *ThreatdragonOutput {
	return &ThreatdragonOutput{
		OutputPath: outputPath,
		cl:         cl,
		logger:     logger.With("package", "threatdragon", "component", "ThreatDragonOutput"),
	}
}

func (tdo *ThreatdragonOutput) Generate(model *common.ThreatModel) error {
	tdo.logger.Debug("Generating threat dragon model")
	var project *Project
	var err error
	tdo.logger.Debug("Checking model.Extra for an existing ThreatDragon model")
	existingTD, ok := model.Extra["ThreatDragonModel"]
	if ok {
		// Cast the existing model to tdRoot
		existingTDModel, ok := existingTD.(Project)
		if !ok {
			return fmt.Errorf("failed to cast existing model to tdRoot")
		}
		tdo.logger.Debug("An existing ThreatDragon model has been found in the model extras. The model will be updated.")
		project, err = tdo.updateExistingModel(model, existingTDModel)
		if err != nil {
			return fmt.Errorf("failed to update existing ThreatDragon model: %w", err)
		}
		tdo.logger.Debug("The existing model has been updated and will be written to file.")
	} else {
		tdo.logger.Info("Found no exsisting model. Creating new a new model")
		project, err = tdo.generateNewModel(model)
		if err != nil {
			return fmt.Errorf("failed to generate new ThreatDragon model: %w", err)
		}
		tdo.logger.Debug("A new model has been generated and will be written to file.")
	}

	err = tdo.writeFile(project)
	if err != nil {
		return err
	}

	tdo.logger.Debug("ThreatDragon model has been written to file", "filePath", tdo.OutputPath)

	return nil
}

func (tdo *ThreatdragonOutput) generateNewModel(model *common.ThreatModel) (*Project, error) {
	const defaultVersion = "2.3.0"
	const defaultTitle = "new Threatdragon Output"
	const defaultOwner = ""
	var defaultDescription = "this model is auto generated by the agile-threat-modeling tool"

	tdo.cl.AddEntry("Starting the threat model generation from scratch (no pre-exisiting model file).")
	outputJson := Project{
		Version: defaultVersion,
		Summary: Summary{
			Title:       defaultTitle,
			Owner:       defaultOwner,
			Description: defaultDescription,
			ID:          0,
		},
		Detail: Detail{
			Contributors: []Contributor{},
		},
	}

	cs := NewCoordinateSystem(tdo.logger)
	cells, err := tdo.generateNewCells(model.Assets, cs)
	if err != nil {
		return nil, err
	}

	outputJson.Detail.Diagrams = []Diagram{
		{
			ID:          0,
			Title:       "new diagramm 0",                               //TODO: add name to config file, if no input is given
			DiagramType: "STRIDE",                                       //TODO: add diagram type to config file if no input is given
			Placeholder: &defaultDescription,                            //TODO: get better infos in the description if not given
			Thumbnail:   "./public/content/images/thumbnail.stride.jpg", //TODO is it okay to hardcode this path? What if Threatdragon changes thier file layout? //replace only if not given
			Version:     defaultVersion,
			Cells:       cells,
		},
	}
	return &outputJson, nil
}

func (tdo *ThreatdragonOutput) updateExistingModel(model *common.ThreatModel, existingTD Project) (*Project, error) {
	coordinateSystems := make([]*CoordinateSystem, 0, len(existingTD.Detail.Diagrams))

	for i, diagram := range existingTD.Detail.Diagrams {
		coordinateSystems = append(coordinateSystems, NewCoordinateSystem(tdo.logger))
		updatedCells := make([]Cell, 0, len(diagram.Cells))

		for j, cell := range diagram.Cells {
			coordinateSystems[i].DetermineOffsetAndWidth(cell)

			// Check if the cell is relevant for analysis
			if !isRelevantType(cell.Data.Type) {
				updatedCells = append(updatedCells, cell)
				continue
			}

			// Check if the model has the asset
			idx := slices.IndexFunc(model.Assets, func(a common.Asset) bool {
				indices, ok := a.Extra["ThreatDragonDiagramCellIdx"].(string)
				if !ok {
					return false
				}
				return indices == fmt.Sprintf("%d-%d", i, j)
			})

			// The asset is in the model when idx greater than 0, so we can update the cell
			if idx >= 0 {
				asset := model.Assets[idx]
				cell := tdo.updateCell(cell, asset)
				updatedCells = append(updatedCells, cell)
			}
		}

		// after updating switch the diagram cells with the updated cells
		existingTD.Detail.Diagrams[i].Cells = updatedCells
	}

	newCells, err := tdo.generateNewCells(model.Assets, coordinateSystems[0])
	if err != nil {
		return nil, err
	}
	existingTD.Detail.Diagrams[0].Cells = append(existingTD.Detail.Diagrams[0].Cells, newCells...)
	return &existingTD, nil
}

type assetTypeInfo struct {
	IsStore          bool // false for process
	IsWebApplication bool
}

func assetTypeToThreatdragonAssetInfo(assetType common.AssetType) (assetTypeInfo, error) {
	switch assetType {
	case common.AssetTypeDatabase:
		return assetTypeInfo{
			IsStore:          true,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeApplication:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeWebserver:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: true,
		}, nil
	case common.AssetTypeInfrastructure:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeUnknown:
		//Unkown asset is respresented as a common process
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	default:
		return assetTypeInfo{}, ErrAssetTypeNoMapping
	}
}

// writeFile simply marshals the data to JSON and writes it to the specified output path
// It uses the json.MarshalIndent function to format the JSON with indentation for better readability.
func (tdo *ThreatdragonOutput) writeFile(data *Project) error {
	content, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	err = createDirIfNotExists(tdo.OutputPath)
	if err != nil {
		return err
	}

	err = os.WriteFile(tdo.OutputPath, content, 0644)
	if err != nil {
		return err
	}

	return nil
}

func createDirIfNotExists(filePath string) error {
	_, err := os.Stat(path.Dir(filePath))

	if err != nil {
		if os.IsNotExist(err) {
			err := os.Mkdir(path.Dir(filePath), os.ModePerm)
			if err != nil {
				return err
			}
			return nil
		}
		return err
	}
	return nil
}

func (tdo *ThreatdragonOutput) generateNewCells(assets []common.Asset, cs *CoordinateSystem) ([]Cell, error) {
	tdo.logger.Debug("Generating new cells for Threat Dragon")
	cells := make([]Cell, 0, len(assets))

	for _, asset := range assets {
		_, ok := asset.Extra["ThreatDragonDiagramCellIdx"]
		if ok {
			// The cell already exists, so we can skip it
			tdo.logger.Debug("Cell already exists in ThreatDragon model and will be skipped.", "name", asset.DisplayName)
			continue
		}

		cell, err := tdo.generateCell(asset, cs)
		if err != nil {
			return nil, err
		}
		cells = append(cells, cell)
	}

	return cells, nil
}

func (tdo *ThreatdragonOutput) generateCell(asset common.Asset, cs *CoordinateSystem) (Cell, error) {
	tdo.logger.Debug("Generating new cell", "name", asset.DisplayName)
	var cell Cell
	threatdragonAssetInfo, err := assetTypeToThreatdragonAssetInfo(asset.Type)
	if err != nil {
		return cell, err
	}

	if threatdragonAssetInfo.IsStore {
		cell = defaultStore()
	} else {
		cell = defaultProcess()
	}

	cell.Data.Description = stringPtr(analyzerIDTag(asset.ID))
	cell.Data.IsWebApplication = &threatdragonAssetInfo.IsWebApplication

	cell.Data.Name = &asset.DisplayName

	cell.Attrs.Text = &TextClass{
		Text: asset.DisplayName,
	}
	tdo.logger.Debug("New asset has been added to ThreatDragon model", "asset", asset)
	tdo.cl.AddEntry(fmt.Sprintf("New asset '%s' has been added from %s", asset.DisplayName, asset.Source.ShortString()))

	PositionCell(cs, &cell)

	return cell, nil
}

func (tdo *ThreatdragonOutput) updateCell(cell Cell, asset common.Asset) Cell {
	oldName := ""
	if cell.Data.Name != nil {
		oldName = *cell.Data.Name
	} else if cell.Attrs.Text != nil {
		oldName = cell.Attrs.Text.Text
	}

	if oldName != asset.DisplayName {
		tdo.logger.Debug("Cell has been renamed", "prev", *cell.Data.Name, "new", asset.DisplayName)
		tdo.cl.AddEntry(fmt.Sprintf("Asset '%s' has been renamed to '%s'", *cell.Data.Name, asset.DisplayName))
	}

	cell.Data.Name = &asset.DisplayName

	cell.Attrs.Text = &TextClass{
		Text: asset.DisplayName,
	}
	return cell
}

// defaultProcess creates a new process cell with default values
// The values were copied from a freshly created process in ThreatDragon
func defaultProcess() Cell {
	return Cell{
		Position: &VertexClass{},
		Size: &Size{
			Height: 60,
			Width:  60,
		},
		Attrs: &CellAttrs{
			Body: &Body{
				Stroke:          stringPtr("#333333"),
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
		},
		Visible: boolPtr(true),
		Shape:   "process",
		Ports: &Ports{
			Groups: PortGroups{
				Top:    defaultPortGroup("top"),
				Right:  defaultPortGroup("right"),
				Bottom: defaultPortGroup("bottom"),
				Left:   defaultPortGroup("left"),
			},
			Items: []Port{
				defaultPort("top"),
				defaultPort("right"),
				defaultPort("bottom"),
				defaultPort("left"),
			},
		},
		ID:     uuid.NewString(),
		ZIndex: 1,
		Data: Data{
			Type:                   "tm.Process",
			Name:                   stringPtr("Process"),
			Description:            stringPtr(""),
			OutOfScope:             boolPtr(false),
			ReasonOutOfScope:       stringPtr(""),
			HasOpenThreats:         false,
			HandlesCardPayment:     boolPtr(false),
			HandlesGoodsOrServices: boolPtr(false),
			IsWebApplication:       boolPtr(false),
			PrivilegeLevel:         stringPtr(""),
			Threats:                &[]Threat{},
		},
	}
}

// defaultStore creates a new store cell with default values
// The values were copied from a freshly created store in ThreatDragon
func defaultStore() Cell {
	return Cell{
		Position: &VertexClass{},
		Size: &Size{
			Height: 60,
			Width:  120,
		},
		Attrs: &CellAttrs{
			TopLine: &Body{
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
			BottomLine: &Body{
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
		},
		Visible: boolPtr(true),
		Shape:   "store",
		Ports: &Ports{
			Groups: PortGroups{
				Top:    defaultPortGroup("top"),
				Right:  defaultPortGroup("right"),
				Bottom: defaultPortGroup("bottom"),
				Left:   defaultPortGroup("left"),
			},
			Items: []Port{
				defaultPort("top"),
				defaultPort("right"),
				defaultPort("bottom"),
				defaultPort("left"),
			},
		},
		ID:     uuid.NewString(),
		ZIndex: 1,
		Data: Data{
			Type:              "tm.Store",
			Name:              stringPtr("Store"),
			Description:       stringPtr(""),
			OutOfScope:        boolPtr(false),
			ReasonOutOfScope:  stringPtr(""),
			HasOpenThreats:    false,
			IsALog:            boolPtr(false),
			IsEncrypted:       boolPtr(false),
			IsSigned:          boolPtr(false),
			StoresCredentials: boolPtr(false),
			StoresInventory:   boolPtr(false),
			Threats:           &[]Threat{},
		},
	}
}

func defaultPortGroup(position string) PortGroup {
	return PortGroup{
		Position: position,
		Attrs: PortGroupAttrs{
			Circle: Circle{
				R:           4,
				Magnet:      true,
				Stroke:      "#5F95FF",
				StrokeWidth: 1,
				Fill:        "#fff",
				Style: Style{
					Visibility: "hidden",
				},
			},
		},
	}
}

func defaultPort(group string) Port {
	return Port{
		Group: group,
		ID:    uuid.NewString(),
	}
}

func nullString() Nullable[string] {
	return Nullable[string]{Set: true, Present: false, Value: ""}
}
