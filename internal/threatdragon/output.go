package threatdragon

import (
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"path"
	"slices"

	"github.com/google/uuid"
	"github.com/threatcat-dev/threatcat/internal/common"
)

type ThreatdragonOutput struct {
	OutputPath string
	cl         changelog
	logger     *slog.Logger
}

type changelog interface {
	AddEntry(string)
}

var ErrAssetTypeNoMapping = errors.New("the used AssetType has no mapping to threatdragonAssetInfo")

func NewThreatdragonOutput(outputPath string, cl changelog, logger *slog.Logger) *ThreatdragonOutput {
	return &ThreatdragonOutput{
		OutputPath: outputPath,
		cl:         cl,
		logger:     logger.With("package", "threatdragon", "component", "ThreatDragonOutput"),
	}
}

func (tdo *ThreatdragonOutput) Generate(model *common.ThreatModel) error {
	tdo.logger.Debug("Generating threat dragon model")
	var project *Project
	var err error
	tdo.logger.Debug("Checking model.Extra for an existing ThreatDragon model")
	existingTD, ok := model.Extra["ThreatDragonModel"]
	if ok {
		// Cast the existing model to tdRoot
		existingTDModel, ok := existingTD.(Project)
		if !ok {
			return fmt.Errorf("failed to cast existing model to tdRoot")
		}
		tdo.logger.Debug("An existing ThreatDragon model has been found in the model extras. The model will be updated.")
		project, err = tdo.updateExistingModel(model, existingTDModel)
		if err != nil {
			return fmt.Errorf("failed to update existing ThreatDragon model: %w", err)
		}
		tdo.logger.Debug("The existing model has been updated and will be written to file.")
	} else {
		tdo.logger.Info("Found no exsisting model. Creating new a new model")
		project, err = tdo.generateNewModel(model)
		if err != nil {
			return fmt.Errorf("failed to generate new ThreatDragon model: %w", err)
		}
		tdo.logger.Debug("A new model has been generated and will be written to file.")
	}

	err = tdo.writeFile(project)
	if err != nil {
		return err
	}

	tdo.logger.Debug("ThreatDragon model has been written to file", "filePath", tdo.OutputPath)

	return nil
}

func (tdo *ThreatdragonOutput) generateNewModel(model *common.ThreatModel) (*Project, error) {
	const defaultVersion = "2.5.0"
	const defaultTitle = "new Threatdragon Output"
	const defaultOwner = ""
	var defaultDescription = "this model is auto generated by threatcat"

	tdo.cl.AddEntry("Starting the threat model generation from scratch (no pre-exisiting model file).")
	outputJson := Project{
		Version: defaultVersion,
		Summary: Summary{
			Title:       defaultTitle,
			Owner:       defaultOwner,
			Description: defaultDescription,
			ID:          0,
		},
		Detail: Detail{
			Contributors: []Contributor{},
		},
	}

	var placementLogic cellPlacer

	solution, err := SolveModel(model.Assets, model.Boundaries)
	if err != nil {
		tdo.logger.Warn("Failed to solve with trust boundaries. Fallback to simple placement")
		placementLogic = newSimplePlacement()
	} else {
		tdo.logger.Info("Solution for trust boundary placement was found")
		placementLogic = &solution
	}

	trustBoundaryCells := tdo.generatePlaceTrustBoundaries(model.Boundaries, placementLogic)
	cells, err := tdo.generatePlaceNewCellsAndDataflows(nil, model.Assets, model.DataFlows, placementLogic)
	if err != nil {
		return nil, err
	}

	outputJson.Detail.Diagrams = []Diagram{
		{
			ID:          0,
			Title:       "new diagram 0",                                //TODO: add name to config file, if no input is given
			DiagramType: "STRIDE",                                       //TODO: add diagram type to config file if no input is given
			Placeholder: &defaultDescription,                            //TODO: get better infos in the description if not given
			Thumbnail:   "./public/content/images/thumbnail.stride.jpg", //TODO is it okay to hardcode this path? What if Threatdragon changes their file layout? //replace only if not given
			Version:     defaultVersion,
			Cells:       append(cells, trustBoundaryCells...),
		},
	}
	return &outputJson, nil
}

func (tdo *ThreatdragonOutput) updateExistingModel(model *common.ThreatModel, existingTD Project) (*Project, error) {
	placements := make([]*simplePlacement, len(existingTD.Detail.Diagrams))
	existingAssets := make([]string, 0, len(model.Assets))

	for i, diagram := range existingTD.Detail.Diagrams {
		updatedCells := make([]Cell, 0, len(diagram.Cells))
		removedCells := make([]Cell, 0, len(diagram.Cells))

		for j, cell := range diagram.Cells {
			// Check if the cell is relevant for analysis
			if !isRelevantType(cell.Data.Type) {
				updatedCells = append(updatedCells, cell)
				continue
			}

			// Check if the model has the asset
			idx := slices.IndexFunc(model.Assets, func(a common.Asset) bool {
				indices, ok := a.Extra["ThreatDragonDiagramCellIdx"].(string)
				if !ok {
					return false
				}
				return indices == fmt.Sprintf("%d-%d", i, j)
			})

			// The asset is in the model when idx greater than 0, so we can update the cell
			if idx >= 0 {
				asset := model.Assets[idx]
				cell, err := tdo.updateCell(cell, asset)
				if err != nil {
					return nil, err
				}
				updatedCells = append(updatedCells, cell)
				existingAssets = append(existingAssets, asset.ID)
			} else {
				// The asset is not in the model, so we save it to remove its connections in the next step
				removedCells = append(removedCells, cell)
			}
		}

		// remove connections to removed cells
		updatedCells = tdo.removeConnections(updatedCells, removedCells)

		// after updating switch the diagram cells with the updated cells
		existingTD.Detail.Diagrams[i].Cells = updatedCells

		placement := newSimplePlacement()
		placement.determineStartingPoint(updatedCells)
		placements[i] = placement
	}

	newAssets := slices.DeleteFunc(slices.Clone(model.Assets), func(a common.Asset) bool {
		return slices.ContainsFunc(existingAssets, func(id string) bool {
			return a.ID == id
		})
	})

	newDataflows := []common.DataFlow{} // TODO: implement data flow updating

	newCells, err := tdo.generatePlaceNewCellsAndDataflows(existingTD.Detail.Diagrams[0].Cells, newAssets, newDataflows, placements[0])
	if err != nil {
		return nil, err
	}
	existingTD.Detail.Diagrams[0].Cells = append(existingTD.Detail.Diagrams[0].Cells, newCells...)
	return &existingTD, nil
}

// Removes connections to removed cells from the updated cells
// If a curve's source or target is connected to a removed cell, the connection is removed
func (tdo *ThreatdragonOutput) removeConnections(updatedCells []Cell, removedCells []Cell) []Cell {
	for _, removedCell := range removedCells {
		for _, cell := range updatedCells {
			// only curves need to be checked for connections
			if !isCurve(cell) {
				continue
			}

			// check if the source is connected to the removed cell
			// if so, update the source to remove the connection
			if cell.Source.Cell != nil && *cell.Source.Cell == removedCell.ID {
				cell.Source = tdo.updateSource(cell.Source, removedCell)
				tdo.logger.Debug("Removed connection from curve cell to removed cell", "curveId", cell.ID, "removedCellID", removedCell.ID)
			}

			// check if the source is connected to the removed cell
			// if so, update the source to remove the connection
			if cell.Target.Cell != nil && *cell.Target.Cell == removedCell.ID {
				cell.Target = tdo.updateSource(cell.Target, removedCell)
				tdo.logger.Debug("Removed connection from curve cell to removed cell", "curveId", cell.ID, "removedCellID", removedCell.ID)
			}
		}
	}
	return updatedCells
}

// updateSource can be used to detach the source or target of a curve (same datatype *Source) from a removed cell
// The x and y coordinates are set to the position of the removed cell based on the port position
// The cell and port are set to nil to remove the connection
func (tdo *ThreatdragonOutput) updateSource(source *Source, removedCell Cell) *Source {
	// Determine the position of the port
	portPosition := ""
	for _, item := range removedCell.Ports.Items {
		if source.Port != nil && item.ID == *source.Port {
			portPosition = item.Group
		}
	}

	// Set the x and y coordinates based on the port position
	// If the port position is not found, the position of the cell is used
	// This should not happen, as the port should always be found
	x := 0.0
	y := 0.0
	switch portPosition {
	case "top":
		x = removedCell.Position.X + removedCell.Size.Width/2
		y = removedCell.Position.Y
	case "right":
		x = removedCell.Position.X + removedCell.Size.Width
		y = removedCell.Position.Y + removedCell.Size.Height/2
	case "bottom":
		x = removedCell.Position.X + removedCell.Size.Width/2
		y = removedCell.Position.Y + removedCell.Size.Height
	case "left":
		x = removedCell.Position.X
		y = removedCell.Position.Y + removedCell.Size.Height/2
	default:
		x = removedCell.Position.X
		y = removedCell.Position.Y
	}
	source.X = int64Ptr(int64(x))
	source.Y = int64Ptr(int64(y))

	// Remove the connection
	source.Cell = nil
	source.Port = nil

	return source
}

type assetTypeInfo struct {
	IsStore          bool // false for process
	IsWebApplication bool
}

func assetTypeToThreatdragonAssetInfo(assetType common.AssetType) (assetTypeInfo, error) {
	switch assetType {
	case common.AssetTypeDatabase:
		return assetTypeInfo{
			IsStore:          true,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeApplication:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeWebserver:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: true,
		}, nil
	case common.AssetTypeInfrastructure:
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	case common.AssetTypeUnknown:
		//Unkown asset is respresented as a common process
		return assetTypeInfo{
			IsStore:          false,
			IsWebApplication: false,
		}, nil
	default:
		return assetTypeInfo{}, ErrAssetTypeNoMapping
	}
}

// writeFile simply marshals the data to JSON and writes it to the specified output path
// It uses the json.MarshalIndent function to format the JSON with indentation for better readability.
func (tdo *ThreatdragonOutput) writeFile(data *Project) error {
	content, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	err = createDirIfNotExists(tdo.OutputPath)
	if err != nil {
		return err
	}

	err = os.WriteFile(tdo.OutputPath, content, 0644)
	if err != nil {
		return err
	}

	return nil
}

func createDirIfNotExists(filePath string) error {
	_, err := os.Stat(path.Dir(filePath))

	if err != nil {
		if os.IsNotExist(err) {
			err := os.Mkdir(path.Dir(filePath), os.ModePerm)
			if err != nil {
				return err
			}
			return nil
		}
		return err
	}
	return nil
}

func (tdo *ThreatdragonOutput) updateCell(cell Cell, asset common.Asset) (Cell, error) {
	// Type of the old cell
	oldType := cell.Data.Type
	//get output type of the asset
	threatdragonAssetInfo, err := assetTypeToThreatdragonAssetInfo(asset.Type)
	if err != nil {
		return Cell{}, err
	}
	var newType string
	//currently the only types that are supported are tm.Process and tm.Store
	if threatdragonAssetInfo.IsStore {
		newType = "tm.Store"
	} else {
		newType = "tm.Process"
	}

	// Check if the type has changed and create a new cell
	if oldType != newType {
		tdo.logger.Debug("Cell type has changed", "prevType", oldType, "newType", newType, "asset", asset.DisplayName)
		cell, err = tdo.updateCellTypePreserveFields(cell, asset)
		if err != nil {
			return Cell{}, err
		}
		tdo.cl.AddEntry(fmt.Sprintf("Asset '%s' type has changed from '%s' to '%s'", asset.DisplayName, oldType, newType))

	}

	//if the cell type has not changed update the existing cell
	oldName := ""
	if cell.Data.Name != nil {
		oldName = *cell.Data.Name
	} else if cell.Attrs.Text != nil {
		oldName = cell.Attrs.Text.Text
	}

	if oldName != asset.DisplayName {
		tdo.logger.Debug("Cell has been renamed", "prevName", *cell.Data.Name, "newName", asset.DisplayName)
		tdo.cl.AddEntry(fmt.Sprintf("Asset '%s' has been renamed to '%s'", *cell.Data.Name, asset.DisplayName))
	}

	cell.Data.Name = &asset.DisplayName

	cell.Data.Threats = updateThreats(asset, tdo.logger, tdo.cl)

	cell.Attrs.Text = &TextClass{
		Text: asset.DisplayName,
	}

	return cell, nil
}

func (tdo *ThreatdragonOutput) updateCellTypePreserveFields(cell Cell, asset common.Asset) (Cell, error) {
	// generate a new cell based on the new type
	newCell, err := tdo.generatePlacedCell(asset, dontPlace{})
	if err != nil {
		return Cell{}, err
	}

	// restore relevant cell fields from the old cell to the new cell
	newCell.Position = cell.Position
	newCell.Size = cell.Size
	newCell.Visible = cell.Visible
	newCell.ZIndex = cell.ZIndex
	newCell.ID = cell.ID
	newCell.Ports = cell.Ports
	newCell.Attrs = cell.Attrs
	newCell.Width = cell.Width
	newCell.Height = cell.Height
	newCell.Connector = cell.Connector
	newCell.Labels = cell.Labels
	newCell.Source = cell.Source
	newCell.Target = cell.Target
	newCell.Vertices = cell.Vertices
	newCell.Tools = cell.Tools

	//restore data fields
	newCell.Data.HasOpenThreats = cell.Data.HasOpenThreats
	newCell.Data.IsTrustBoundary = cell.Data.IsTrustBoundary
	newCell.Data.OutOfScope = cell.Data.OutOfScope
	newCell.Data.ReasonOutOfScope = cell.Data.ReasonOutOfScope
	newCell.Data.ProvidesAuthentication = cell.Data.ProvidesAuthentication
	newCell.Data.Threats = cell.Data.Threats
	newCell.Data.HandlesCardPayment = cell.Data.HandlesCardPayment
	newCell.Data.HandlesGoodsOrServices = cell.Data.HandlesGoodsOrServices
	newCell.Data.PrivilegeLevel = cell.Data.PrivilegeLevel
	newCell.Data.IsBidirectional = cell.Data.IsBidirectional
	newCell.Data.IsEncrypted = cell.Data.IsEncrypted
	newCell.Data.IsPublicNetwork = cell.Data.IsPublicNetwork
	newCell.Data.Protocol = cell.Data.Protocol
	newCell.Data.IsALog = cell.Data.IsALog
	newCell.Data.IsSigned = cell.Data.IsSigned
	newCell.Data.StoresCredentials = cell.Data.StoresCredentials
	newCell.Data.StoresInventory = cell.Data.StoresInventory
	newCell.Data.ThreatFrequency = cell.Data.ThreatFrequency

	return *newCell, nil
}

// generateThreats converts a slice of common.Threat to a slice of ThreatDragon Threat
func generateThreats(asset common.Asset) []Threat {
	tdThreats := []Threat{}
	for _, threat := range asset.Threats {
		tdThreats = append(tdThreats, generateThreat(threat))
	}
	return tdThreats
}

// generateThreat converts a common.Threat to a ThreatDragon Threat
func generateThreat(threat common.Threat) Threat {

	// number: only mark as Set/Present when non-zero
	var num Nullable[int64]
	if threat.Number != 0 {
		num = Nullable[int64]{Value: threat.Number, Set: true, Present: true}
	} else {
		num = Nullable[int64]{Set: false, Present: false}
	}

	// score: only mark as Set/Present when non-empty
	var score Nullable[string]
	if threat.Score != "" {
		score = Nullable[string]{Value: threat.Score, Set: true, Present: true}
	} else {
		score = Nullable[string]{Set: false, Present: false}
	}

	description := analyzerIDTag(threat.InternalID)
	if threat.Description != "" {
		description += " " + threat.Description
	}

	modelThreat := Threat{
		ID:          threat.ID,
		Title:       threat.Title,
		Status:      common.StatusString(threat.Status),
		Severity:    threat.Severity,
		Type:        common.TypeString(threat.Type),
		Description: description,
		Mitigation:  threat.Mitigation,
		ModelType:   common.ModelString(threat.ModelType),
		Number:      num,
		Score:       score,
	}
	return modelThreat
}

// updateThreats updates the threats of a model based on the threats in the assets
// It preserves the ID of existing threats and adds new threats
// It also logs changes to the changelog
func updateThreats(asset common.Asset, logger *slog.Logger, cl changelog) *[]Threat {
	// safely obtain ThreatModelMap from asset.Extra if present
	existingThreats := common.GetOr(asset.Extra, "ThreatModelMap", make(map[int]Threat))

	updatedThreats := make([]Threat, 0, len(asset.Threats))

	// fast path: return nil when nil
	if asset.Threats == nil && existingThreats == nil {
		return nil
	}

	// fast path: return empty slice when empty
	if (len(asset.Threats) == 0) && (len(existingThreats) == 0) {
		return &updatedThreats
	}

	// Iterate over all threats in the asset
	for _, threat := range asset.Threats {
		existingThreat := Threat{}
		exists := false
		if threat.MapIndex >= 0 {
			existingThreat, exists = existingThreats[threat.MapIndex]
		}

		// The threat already exists, so we add it (does not need to be updated))
		if exists {
			updatedThreats = append(updatedThreats, existingThreat)
		} else {
			// Threat not found in existing threats, treat as new
			updatedThreats = append(updatedThreats, generateThreat(threat))
			logger.Debug("Threat not found in existing threats, adding as new", "threat", threat.Title)
			cl.AddEntry(fmt.Sprintf("New threat '%s' has been added", threat.Title))
		}
	}

	//Handle removed threats to be added afterwards
	for _, threat := range existingThreats {
		if common.ThreatModelType(threat.ModelType) == common.NotSupported || common.ThreatThreatType(threat.Type) == common.ThreatTypeUnknown {
			logger.Debug("Existing threat has unsupported type or model type and will be added", "threat", threat.Title)
			updatedThreats = append(updatedThreats, threat)
		}
	}

	if len(updatedThreats) > 0 {
		return &updatedThreats
	} else {
		return nil
	}
}

// ============================= NEW IMPLEMENTATION ==========================================

type cellPlacer interface {
	GetPosition(assetID string) (float64, float64)
	GetBoundaryPosition(boundaryID string) (float64, float64, float64, float64)
}

func (tdo *ThreatdragonOutput) generatePlaceTrustBoundaries(boundaries []common.TrustBoundary, placementLogic cellPlacer) []Cell {
	tdo.logger.Debug("Generating new trust boundaries for Threat Dragon")
	newTrustBoundaries := make([]Cell, 0, len(boundaries))

	for _, boundary := range boundaries {
		tdo.logger.Debug("Generating new trust boundary", "name", boundary.DisplayName)
		x, y, w, h := placementLogic.GetBoundaryPosition(boundary.ID)
		description := analyzerIDTag(boundary.ID)
		placedBoundary := trustBoundary(x, y, w, h, boundary.DisplayName, description)
		newTrustBoundaries = append(newTrustBoundaries, placedBoundary)
		tdo.cl.AddEntry(fmt.Sprintf("New trust boundary '%s' has been added from %s", boundary.DisplayName, boundary.Source.ShortString()))
	}

	return newTrustBoundaries
}

func (tdo *ThreatdragonOutput) generatePlaceNewCellsAndDataflows(existingCells []Cell, newAssets []common.Asset, newDataflows []common.DataFlow, placementLogic cellPlacer) ([]Cell, error) {
	tdo.logger.Debug("Generating new cells for Threat Dragon")
	newCells := make([]Cell, 0, len(newAssets)+len(newDataflows))

	for _, asset := range newAssets {
		tdo.logger.Debug("Generating new cell", "name", asset.DisplayName)
		placedCell, err := tdo.generatePlacedCell(asset, placementLogic)
		if err != nil {
			return nil, fmt.Errorf("failed to generate placed cell: %w", err)
		}
		newCells = append(newCells, *placedCell)
		tdo.cl.AddEntry(fmt.Sprintf("New asset '%s' has been added from %s", asset.DisplayName, asset.Source.ShortString()))
	}

	placedCells := slices.Clone(existingCells)
	placedCells = append(placedCells, newCells...)
	for _, dataflow := range newDataflows {
		connectedDataflow, err := tdo.generateConnectedDataflow(dataflow, placedCells)
		if err != nil {
			return nil, fmt.Errorf("failed to generated connected dataflow: %w", err)
		}
		newCells = append(newCells, *connectedDataflow)
	}

	return newCells, nil
}

func (tdo *ThreatdragonOutput) generatePlacedCell(asset common.Asset, placementLogic cellPlacer) (*Cell, error) {
	threatdragonAssetInfo, err := assetTypeToThreatdragonAssetInfo(asset.Type)
	if err != nil {
		return nil, err
	}

	name := asset.DisplayName
	description := analyzerIDTag(asset.ID)
	isStore := threatdragonAssetInfo.IsStore
	isWebApp := threatdragonAssetInfo.IsWebApplication
	threats := generateThreats(asset)
	x, y := placementLogic.GetPosition(asset.ID)

	var cell Cell
	if isStore {
		cell = store(name, description, threats, x, y)
	} else {
		cell = process(name, description, isWebApp, threats, x, y)
	}

	return &cell, nil
}

func (tdo *ThreatdragonOutput) generateConnectedDataflow(dataflow common.DataFlow, placedCells []Cell) (*Cell, error) {
	var source, target *Cell
	for _, cell := range placedCells {
		if *cell.Data.Name == dataflow.Source {
			source = &cell
		}
		if *cell.Data.Name == dataflow.Target {
			target = &cell
		}
	}
	if source == nil {
		return nil, fmt.Errorf("failed to find cell id for dataflow source connection: '%s'", dataflow.Source)
	}
	if target == nil {
		return nil, fmt.Errorf("failed to find cell id for dataflow target connection: '%s'", dataflow.Source)
	}

	description := analyzerIDTag(dataflow.ID)

	cell := newDataflow(
		dataflow.Name,
		description,
		dataflow.Protocol,
		dataflow.PublicNetwork,
		dataflow.Encrypted,
		source,
		target,
		dataflow.Bidirectional,
	)

	return &cell, nil
}

// =============================================================================================

// defaultProcess creates a new process cell with default values
// The values were copied from a freshly created process in ThreatDragon
func process(name, description string, isWebApp bool, threats []Threat, x, y float64) Cell {
	return Cell{
		Position: &VertexClass{
			X: x,
			Y: y,
		},
		Size: &Size{
			Height: 60,
			Width:  60,
		},
		Attrs: &CellAttrs{
			Body: &Body{
				Stroke:          stringPtr("#333333"),
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
			Text: &TextClass{
				Text: name,
			},
		},
		Visible: boolPtr(true),
		Shape:   "process",
		Ports: &Ports{
			Groups: PortGroups{
				Top:    defaultPortGroup("top"),
				Right:  defaultPortGroup("right"),
				Bottom: defaultPortGroup("bottom"),
				Left:   defaultPortGroup("left"),
			},
			Items: []Port{
				defaultPort("top"),
				defaultPort("right"),
				defaultPort("bottom"),
				defaultPort("left"),
			},
		},
		ID:     uuid.NewString(),
		ZIndex: 1,
		Data: Data{
			Type:                   "tm.Process",
			Name:                   &name,
			Description:            &description,
			OutOfScope:             boolPtr(false),
			ReasonOutOfScope:       stringPtr(""),
			HasOpenThreats:         hasOpenThreats(threats),
			HandlesCardPayment:     boolPtr(false),
			HandlesGoodsOrServices: boolPtr(false),
			IsWebApplication:       &isWebApp,
			PrivilegeLevel:         stringPtr(""),
			Threats:                &threats,
		},
	}
}

// defaultStore creates a new store cell with default values
// The values were copied from a freshly created store in ThreatDragon
func store(name, description string, threats []Threat, x, y float64) Cell {
	return Cell{
		Position: &VertexClass{
			X: x,
			Y: y,
		},
		Size: &Size{
			Height: 60,
			Width:  120,
		},
		Attrs: &CellAttrs{
			TopLine: &Body{
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
			BottomLine: &Body{
				StrokeWidth:     1.5,
				StrokeDasharray: nullString(),
			},
			Text: &TextClass{
				Text: name,
			},
		},
		Visible: boolPtr(true),
		Shape:   "store",
		Ports: &Ports{
			Groups: PortGroups{
				Top:    defaultPortGroup("top"),
				Right:  defaultPortGroup("right"),
				Bottom: defaultPortGroup("bottom"),
				Left:   defaultPortGroup("left"),
			},
			Items: []Port{
				defaultPort("top"),
				defaultPort("right"),
				defaultPort("bottom"),
				defaultPort("left"),
			},
		},
		ID:     uuid.NewString(),
		ZIndex: 1,
		Data: Data{
			Type:              "tm.Store",
			Name:              &name,
			Description:       &description,
			OutOfScope:        boolPtr(false),
			ReasonOutOfScope:  stringPtr(""),
			HasOpenThreats:    hasOpenThreats(threats),
			IsALog:            boolPtr(false),
			IsEncrypted:       boolPtr(false),
			IsSigned:          boolPtr(false),
			StoresCredentials: boolPtr(false),
			StoresInventory:   boolPtr(false),
			Threats:           &threats,
		},
	}
}

func hasOpenThreats(threats []Threat) bool {
	return slices.ContainsFunc(threats, func(t Threat) bool {
		return t.Status == common.StatusString(common.Open)
	})
}

func trustBoundary(x, y, w, h float64, name, description string) Cell {
	return Cell{
		ID: uuid.NewString(),
		Position: &VertexClass{
			X: x,
			Y: y,
		},
		Size: &Size{
			Width:  w,
			Height: h,
		},
		Attrs: &CellAttrs{
			Label: &TextClass{
				Text: name,
			},
		},
		Visible: boolPtr(true),
		Shape:   "trust-boundary-box",
		ZIndex:  -1,
		Data: Data{
			Type:            "tm.BoundaryBox",
			Name:            &name,
			Description:     &description,
			IsTrustBoundary: boolPtr(true),
			HasOpenThreats:  false,
		},
	}
}

func defaultPortGroup(position string) PortGroup {
	return PortGroup{
		Position: position,
		Attrs: PortGroupAttrs{
			Circle: Circle{
				R:           4,
				Magnet:      true,
				Stroke:      "#5F95FF",
				StrokeWidth: 1,
				Fill:        "#fff",
				Style: Style{
					Visibility: "hidden",
				},
			},
		},
	}
}

func defaultPort(group string) Port {
	return Port{
		Group: group,
		ID:    uuid.NewString(),
	}
}

// Creates a new default data flow
func newDataflow(name, description string, protocol string, publicNetwork, encrypted bool, source, target *Cell, bidirectional bool) Cell {
	cell := Cell{
		Shape: "flow",
		Attrs: &CellAttrs{
			Line: &Line{
				Stroke: stringPtr("#333333"),
				TargetMarker: &Marker{
					Contributor: &Contributor{Name: "block"},
				},
				SourceMarker: &Marker{
					Contributor: &Contributor{Name: ""},
				},
				StrokeDasharray: Nullable[string]{},
			},
		},
		Width:     float64Ptr(200),
		Height:    float64Ptr(100),
		ZIndex:    10,
		Connector: stringPtr("smooth"),
		Data: Data{
			Type:             "tm.Flow",
			Name:             &name,
			Description:      &description,
			OutOfScope:       boolPtr(false),
			IsTrustBoundary:  boolPtr(false),
			ReasonOutOfScope: stringPtr(""),
			HasOpenThreats:   false,
			IsBidirectional:  &bidirectional,
			IsEncrypted:      &encrypted,
			IsPublicNetwork:  &publicNetwork,
			Protocol:         &protocol,
			Threats:          &[]Threat{},
		},
		Labels: []LabelElement{
			{
				String: &name,
			},
		},
		Source: &Source{
			Cell: &source.ID,
			Port: &source.Ports.Items[1].ID,
		},
		Target: &Source{
			Cell: &target.ID,
			Port: &target.Ports.Items[1].ID,
		},
		ID: uuid.NewString(),
	}

	if bidirectional {
		cell.Attrs.Line.SourceMarker.Contributor.Name = "block"
	}

	return cell
}

func nullString() Nullable[string] {
	return Nullable[string]{Set: true, Present: false, Value: ""}
}
